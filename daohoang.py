# daohoang.py ‚Äî SQLite (.db) + qu·∫£n tr·ªã admin
import sqlite3, json, os, re, random, time

DB_FILE = "players.db"

# ===== C·∫§U H√åNH ADMIN (d·ª±a theo username) =====
# Ai c√≥ username trong set n√†y s·∫Ω t·ª± nh·∫≠n admin ·ªü l·∫ßn ƒë·∫ßu t·∫°o t√†i kho·∫£n.
# Sau ƒë√≥ c√≥ th·ªÉ c·∫•p/thu h·ªìi b·∫±ng ksetadmin.
ADMIN_USERNAMES = {"admin", "sr.nguoihanhtinh_vnvodich","sr_baby_wanna_cry","villain911"}

# ===== SHOP & BONUS =====
shop_items = {
    "cuocgo": 10,         # +1/farm
    "cuocsat": 20,        # +2/farm
    "cuocvang": 50,       # +5/farm
    "cuockimcuong": 100,  # +10/farm
    "khien": 10,          # -15% t·ªâ l·ªá ch·∫øt cho 1 l·∫ßn farm (ti√™u hao 1/l·∫ßn)
    "khienvip": 200,      # mi·ªÖn t·ª≠ 100% | m·ªói m√≥n = 10 l∆∞·ª£t s·ª≠ d·ª•ng
    "thuoc": 100          # booster x2 farm trong 5 ph√∫t (ti√™u hao khi d√πng)
}
tool_bonus = {"cuocgo": 1, "cuocsat": 2, "cuocvang": 5, "cuockimcuong": 10}

# ===== C·∫§U H√åNH GAME =====
DEATH_CHANCE_DEFAULT = 0.35      # t·ªâ l·ªá ch·∫øt m·∫∑c ƒë·ªãnh 35%
SHIELD_DEATH_REDUCTION = 0.15    # khi√™n th∆∞·ªùng gi·∫£m 15%
DEATH_PENALTY_RATIO = 0.5        # ch·∫øt m·∫•t 50% coin hi·ªán c√≥
FARM_COOLDOWN = 10               # 10s m·ªói l·∫ßn farm (Admin: kh√¥ng cooldown)
ADVENTURE_CD = 1800              # 30 ph√∫t
PVP_CD = 3600                    # 1 gi·ªù
DAILY_RESET = 86400              # 24 gi·ªù

MENTION_RE = re.compile(r"^<@!?(\d+)>$")

# ====== DB LAYER ======
def _db():
    conn = sqlite3.connect(DB_FILE)
    conn.row_factory = sqlite3.Row
    return conn

def _init_db():
    conn = _db()
    cur = conn.cursor()
    cur.execute("""
    CREATE TABLE IF NOT EXISTS players (
        id TEXT PRIMARY KEY,
        username TEXT NOT NULL,
        coin INTEGER NOT NULL DEFAULT 0,
        exp INTEGER NOT NULL DEFAULT 0,
        level INTEGER NOT NULL DEFAULT 1,
        ban INTEGER NOT NULL DEFAULT 0,
        is_admin INTEGER NOT NULL DEFAULT 0,
        inventory TEXT NOT NULL DEFAULT '{}',
        last_farm_time REAL NOT NULL DEFAULT 0,
        last_adventure REAL NOT NULL DEFAULT 0,
        last_pvp REAL NOT NULL DEFAULT 0,
        booster_until REAL NOT NULL DEFAULT 0,
        daily_farm INTEGER NOT NULL DEFAULT 0,
        daily_completed INTEGER NOT NULL DEFAULT 0,
        daily_last_reset REAL NOT NULL DEFAULT 0
    )""")
    cur.execute("""
    CREATE TABLE IF NOT EXISTS settings (
        key TEXT PRIMARY KEY,
        value TEXT NOT NULL
    )""")
    # defaults
    _set_setting("death_chance", DEATH_CHANCE_DEFAULT)
    if _get_setting("farm_channel_id") is None:
        _set_setting("farm_channel_id", None)
    conn.commit()
    conn.close()

def _get_setting(key):
    conn = _db()
    cur = conn.cursor()
    cur.execute("SELECT value FROM settings WHERE key=?", (key,))
    row = cur.fetchone()
    conn.close()
    if not row:
        return None
    try:
        return json.loads(row["value"])
    except Exception:
        return row["value"]

def _set_setting(key, value):
    conn = _db()
    cur = conn.cursor()
    cur.execute(
        "INSERT INTO settings(key, value) VALUES(?, ?) "
        "ON CONFLICT(key) DO UPDATE SET value=excluded.value",
        (key, json.dumps(value, ensure_ascii=False))
    )
    conn.commit()
    conn.close()

def _fmt(n: int) -> str:
    return f"{int(n):,}".replace(",", ".")

def _parse_pos_int(s: str):
    clean = str(s).replace(".", "").replace(",", "")
    if not clean.isdigit():
        return None
    val = int(clean)
    return val if val > 0 else None

def _is_admin_username(username: str) -> bool:
    return username in ADMIN_USERNAMES

def _row_to_user(row):
    inv = {}
    try:
        inv = json.loads(row["inventory"]) if row["inventory"] else {}
    except Exception:
        inv = {}
    return {
        "id": row["id"],
        "username": row["username"],
        "coin": row["coin"],
        "exp": row["exp"],
        "level": row["level"],
        "ban": bool(row["ban"]),
        "is_admin": bool(row["is_admin"]),
        "inventory": inv,
        "last_farm_time": row["last_farm_time"],
        "last_adventure": row["last_adventure"],
        "last_pvp": row["last_pvp"],
        "booster_until": row["booster_until"],
        "daily_progress": {
            "farm": row["daily_farm"],
            "completed": bool(row["daily_completed"]),
            "last_reset": row["daily_last_reset"],
        }
    }

def _save_user(user):
    conn = _db()
    cur = conn.cursor()
    inv_json = json.dumps(user["inventory"], ensure_ascii=False)
    dp = user["daily_progress"]
    cur.execute("""
    UPDATE players SET
        username=?, coin=?, exp=?, level=?, ban=?, is_admin=?,
        inventory=?, last_farm_time=?, last_adventure=?, last_pvp=?,
        booster_until=?, daily_farm=?, daily_completed=?, daily_last_reset=?
    WHERE id=?""", (
        user["username"], int(user["coin"]), int(user["exp"]), int(user["level"]),
        1 if user["ban"] else 0, 1 if user["is_admin"] else 0,
        inv_json, float(user["last_farm_time"]), float(user["last_adventure"]), float(user["last_pvp"]),
        float(user["booster_until"]), int(dp["farm"]), 1 if dp["completed"] else 0, float(dp["last_reset"]),
        user["id"]
    ))
    conn.commit()
    conn.close()

def _get_user_by_id(uid: str):
    conn = _db()
    cur = conn.cursor()
    cur.execute("SELECT * FROM players WHERE id=?", (uid,))
    row = cur.fetchone()
    conn.close()
    return _row_to_user(row) if row else None

def _get_user_by_name(name: str):
    conn = _db()
    cur = conn.cursor()
    cur.execute("SELECT * FROM players WHERE lower(username)=lower(?) LIMIT 1", (name,))
    row = cur.fetchone()
    conn.close()
    return _row_to_user(row) if row else None

def _create_user(uid: str, username: str):
    conn = _db()
    cur = conn.cursor()
    cur.execute("""INSERT OR IGNORE INTO players
        (id, username, coin, exp, level, ban, is_admin, inventory,
         last_farm_time, last_adventure, last_pvp,
         booster_until, daily_farm, daily_completed, daily_last_reset)
         VALUES (?, ?, 0, 0, 1, 0, ?, '{}', 0, 0, 0, 0, 0, 0, 0)
    """, (uid, username, 1 if _is_admin_username(username) else 0))
    conn.commit()
    conn.close()
    return _get_user_by_id(uid)

def _find_user_key_by_token(token: str):
    token = token.strip()
    m = MENTION_RE.match(token)
    if m:
        uid = m.group(1)
        if _get_user_by_id(uid): return uid
        return None
    u = _get_user_by_name(token)
    return u["id"] if u else None

def _calc_farm_bonus(user_dict: dict) -> int:
    inv = user_dict.get("inventory", {})
    return sum(int(inv.get(name, 0)) * per for name, per in tool_bonus.items())

def _calc_level_bonus(level: int) -> float:
    return 1 + (level * 0.02)   # +2% m·ªói c·∫•p

def _gain_exp(user, gain):
    exp_add = gain // 10
    user["exp"] += exp_add
    needed = user["level"] * 100
    leveled = False
    while user["exp"] >= needed:
        user["exp"] -= needed
        user["level"] += 1
        needed = user["level"] * 100
        leveled = True
    return leveled, exp_add

def _check_daily_reset(user):
    now = time.time()
    dp = user["daily_progress"]
    if now - dp.get("last_reset", 0) > DAILY_RESET:
        user["daily_progress"] = {"farm": 0, "completed": False, "last_reset": now}

def _reset_user_fields(user: dict):
    """RS d·ªØ li·ªáu ng∆∞·ªùi ch∆°i v·ªÅ m·∫∑c ƒë·ªãnh, gi·ªØ username & quy·ªÅn admin."""
    keep_name = user["username"]
    keep_admin = user["is_admin"]
    user.update({
        "username": keep_name,
        "coin": 0,
        "exp": 0,
        "level": 1,
        "ban": False,
        "is_admin": keep_admin,
        "inventory": {},
        "last_farm_time": 0,
        "last_adventure": 0,
        "last_pvp": 0,
        "booster_until": 0,
        "daily_progress": {"farm": 0, "completed": False, "last_reset": 0}
    })

# ===== API PUBLIC =====
def create_discord_account(user_id, username):
    _init_db()
    uid = str(user_id)
    user = _get_user_by_id(uid)
    if not user:
        user = _create_user(uid, username)
    # update username & admin flag if changed
    if user["username"] != username or user["is_admin"] != _is_admin_username(username):
        user["username"] = username
        # l∆∞u quy·ªÅn admin hi·ªán c√≥; kh√¥ng t·ª± override n·∫øu ƒë√£ set b·∫±ng l·ªánh
        # ch·ªâ auto-grant n·∫øu tr∆∞·ªõc ƒë√≥ ch∆∞a c√≥ v√† username thu·ªôc ADMIN_USERNAMES
        if not user["is_admin"] and _is_admin_username(username):
            user["is_admin"] = True
        _save_user(user)
    return user

def get_user(user_id):
    _init_db()
    return _get_user_by_id(str(user_id))

# ===== GAME HELPERS (kcf / slots / bj) =====
def _bet_check(user, bet):
    if bet is None or bet <= 0:
        return "‚ùå C∆∞·ª£c ph·∫£i l√† s·ªë > 0."
    if user["coin"] < bet:
        return f"‚ùå Kh√¥ng ƒë·ªß coin ƒë·ªÉ c∆∞·ª£c {_fmt(bet)}! B·∫°n c√≥ {_fmt(user['coin'])}."
    return None

def _coinflip_play(user, bet, side):  # side in {"h","t"} = head/tail
    err = _bet_check(user, bet)
    if err: return err
    side = side.lower()
    if side not in ("h","t"):
        return "‚ùå D√πng: `kcf <ti·ªÅn_c∆∞·ª£c> <h|t>` (h=heads/ng·ª≠a, t=tails/s·∫•p)"
    user["coin"] -= bet
    roll = random.choice(("h","t"))
    if roll == side:
        user["coin"] += bet * 2
        txt = f"üéâ Th·∫Øng! +{_fmt(bet)}"
    else:
        txt = f"üí• Thua! -{_fmt(bet)}"
    _save_user(user)
    return f"ü™ô **Coinflip** ‚Üí ra: {roll.upper()} ü™ô\n{txt} ‚Ä¢ S·ªë d∆∞: {_fmt(user['coin'])}"

_SLOTS_SYMS = ["üçí","üçã","üîî","‚≠ê","7Ô∏è‚É£"]
def _slots_play(user, bet):
    err = _bet_check(user, bet)
    if err: return err
    user["coin"] -= bet
    a,b,c = [random.choice(_SLOTS_SYMS) for _ in range(3)]
    reels = f"{a} | {b} | {c}"

    mult = 0
    if a==b==c=="7Ô∏è‚É£": mult=10
    elif a==b==c: mult=5
    elif a==b or a==c or b==c: mult=2

    if mult>0:
        gain = bet*mult
        user["coin"] += gain
        _save_user(user)
        return f"üé∞ **Slots** ‚Üí {reels}\nüéâ Tr√∫ng x{mult}! L√£i {_fmt(gain-bet)}. S·ªë d∆∞: {_fmt(user['coin'])}"
    else:
        _save_user(user)
        return f"üé∞ **Slots** ‚Üí {reels}\nüí• Tr∆∞·ª£t r·ªìi! M·∫•t {_fmt(bet)}. S·ªë d∆∞: {_fmt(user['coin'])}"

def _bj_draw():
    ranks = [2,3,4,5,6,7,8,9,10,10,10,10,11]  # J,Q,K=10; A=11
    return random.choice(ranks)

def _bj_value(cards):
    total = sum(cards); aces = cards.count(11)
    while total>21 and aces>0:
        total -= 10; aces -= 1
    return total

def _bj_play(user, bet):
    err = _bet_check(user, bet)
    if err: return err
    user["coin"] -= bet
    player = [_bj_draw(), _bj_draw()]
    dealer = [_bj_draw(), _bj_draw()]
    while _bj_value(player) < 17: player.append(_bj_draw())
    while _bj_value(dealer) < 17: dealer.append(_bj_draw())
    pv, dv = _bj_value(player), _bj_value(dealer)
    cards = lambda xs: " ".join([("A" if x==11 else str(x)) for x in xs])
    head = f"üÉè **Blackjack**\nB·∫°n: {cards(player)} (= {pv})\nNh√† c√°i: {cards(dealer)} (= {dv})"
    if pv>21:
        _save_user(user); return f"{head}\nüí• B·∫°n qu·∫Øc (>21). M·∫•t {_fmt(bet)}. S·ªë d∆∞: {_fmt(user['coin'])}"
    if dv>21 or pv>dv:
        user["coin"] += bet*2; _save_user(user)
        return f"{head}\nüéâ B·∫°n th·∫Øng! L√£i {_fmt(bet)}. S·ªë d∆∞: {_fmt(user['coin'])}"
    if pv==dv:
        user["coin"] += bet; _save_user(user)
        return f"{head}\nü§ù H√≤a! Ho√†n ti·ªÅn. S·ªë d∆∞: {_fmt(user['coin'])}"
    _save_user(user); return f"{head}\nüí• Thua! M·∫•t {_fmt(bet)}. S·ªë d∆∞: {_fmt(user['coin'])}"

# ===== COMMAND DISPATCH =====
def process_command(user_id, username, cmd, channel_id=None):
    _init_db()
    user = create_discord_account(user_id, username)

    _check_daily_reset(user)
    if user["ban"]:
        return "üö´ B·∫°n ƒë√£ b·ªã ban!"
    _save_user(user)  # l∆∞u last_reset n·∫øu c√≥

    parts = cmd.split()
    if not parts:
        return "‚ùå L·ªánh kh√¥ng h·ª£p l·ªá!"
    action = parts[0]

    # Gi·ªõi h·∫°n k√™nh farm n·∫øu c√≥
    farm_channel_id = _get_setting("farm_channel_id")
    if action == "kfarm" and farm_channel_id is not None:
        if channel_id and str(channel_id) != str(farm_channel_id):
            return f"üö´ B·∫°n ch·ªâ c√≥ th·ªÉ farm trong <#{farm_channel_id}>!"

    # ===== FARM =====
    if action == "kfarm":
        now = time.time()
        # Admin KH√îNG cooldown
        if not user["is_admin"]:
            if now - user["last_farm_time"] < FARM_COOLDOWN:
                remain = FARM_COOLDOWN - (now - user["last_farm_time"])
                return f"‚è≥ C√≤n {remain:.1f}s n·ªØa m·ªõi farm ƒë∆∞·ª£c!"
        user["last_farm_time"] = now

        inv = user["inventory"]
        death_chance = float(_get_setting("death_chance") or DEATH_CHANCE_DEFAULT)
        effective_death = death_chance

        # ∆Øu ti√™n d√πng KHIENTVIP (m·ªói m√≥n = 10 l∆∞·ª£t; inventory l∆∞u s·ªë l∆∞·ª£t)
        vip_uses = int(inv.get("khienvip", 0))
        if vip_uses > 0:
            inv["khienvip"] = vip_uses - 1
            effective_death = 0.0
        else:
            shields = int(inv.get("khien", 0))
            if shields > 0:
                inv["khien"] = shields - 1
                effective_death = max(0.0, effective_death - SHIELD_DEATH_REDUCTION)

        if random.random() < effective_death:
            lost = int(user["coin"] * DEATH_PENALTY_RATIO)
            user["coin"] -= lost
            _save_user(user)
            return f"üíÄ {username} ch·∫øt khi ƒë√†o! M·∫•t {_fmt(lost)} coin (c√≤n {_fmt(user['coin'])})."

        base = random.randint(5, 10)
        bonus = _calc_farm_bonus(user)
        level_bonus = _calc_level_bonus(user["level"])
        gain = int((base + bonus) * level_bonus)

        # booster x2 n·∫øu c√≤n hi·ªáu l·ª±c
        if now < user.get("booster_until", 0):
            gain *= 2

        user["coin"] += gain
        leveled, exp_gain = _gain_exp(user, gain)
        user["daily_progress"]["farm"] += 1
        _save_user(user)

        msg = f"üåæ {username} nh·∫≠n {_fmt(gain)} coin (+{_fmt(exp_gain)} exp). T·ªïng: {_fmt(user['coin'])}"
        if leveled:
            msg += f"\nüéâ **L√äN C·∫§P!** ‚Üí Level {user['level']} (ƒë√†o m·∫°nh h∆°n +2%)"
        return msg

    # ===== BOOSTER / STATUS =====
    elif action == "kdung":
        if len(parts) < 2 or parts[1].lower() != "thuoc":
            return "‚ùå D√πng: `kdung thuoc` ƒë·ªÉ k√≠ch ho·∫°t x2 farm trong 5 ph√∫t."
        inv = user["inventory"]
        have = int(inv.get("thuoc", 0))
        if have <= 0:
            return "‚ùå B·∫°n kh√¥ng c√≥ 'thuoc'. Mua ·ªü `kshop` (100 coin)."
        inv["thuoc"] = have - 1
        user["booster_until"] = time.time() + 300
        _save_user(user)
        return "üß™ ƒê√£ d√πng **thuoc**! Trong 5 ph√∫t t·ªõi **x2** coin khi farm."

    elif action == "kstatus":
        now = time.time()
        booster_left = max(0, int(user.get("booster_until", 0) - now))
        eff = []
        eff.append(f"üß™ Booster x2 c√≤n {booster_left}s" if booster_left > 0 else "üß™ Booster: kh√¥ng ho·∫°t ƒë·ªông")
        death_pct = int(float(_get_setting("death_chance") or DEATH_CHANCE_DEFAULT) * 100)
        eff.append(f"‚ò†Ô∏è T·ªâ l·ªá ch·∫øt hi·ªán t·∫°i: {death_pct}% (khi√™n th∆∞·ªùng -15%/l∆∞·ª£t)")
        cd_left = 0 if user.get("is_admin") else max(0, int(FARM_COOLDOWN - (time.time() - user.get('last_farm_time', 0))))
        eff.append(f"‚è≥ Farm cooldown c√≤n: {cd_left}s")
        vip_left = int(user["inventory"].get("khienvip", 0))
        if vip_left > 0:
            eff.append(f"üõ°Ô∏è Khi√™n VIP l∆∞·ª£t c√≤n: {vip_left}")
        return "üìä **Tr·∫°ng th√°i**:\n" + "\n".join(eff)

    # ===== ADVENTURE =====
    elif action == "kadventure":
        now = time.time()
        if now - user["last_adventure"] < ADVENTURE_CD:
            remain = ADVENTURE_CD - (now - user["last_adventure"])
            return f"üß≠ H√£y ngh·ªâ {int(remain//60)} ph√∫t n·ªØa r·ªìi kh√°m ph√° ti·∫øp!"
        user["last_adventure"] = now
        roll = random.random()
        if roll < 0.6:
            reward = random.randint(50, 500)
            user["coin"] += reward
            _save_user(user)
            return f"üó∫Ô∏è {username} t√¨m ƒë∆∞·ª£c kho b√°u nh·ªè ch·ª©a {_fmt(reward)} coin!"
        elif roll < 0.85:
            item = random.choice(list(shop_items.keys()))
            inv = user["inventory"]; inv[item] = inv.get(item, 0) + 1
            _save_user(user)
            return f"üéÅ {username} t√¨m th·∫•y 1 {item} khi kh√°m ph√°!"
        else:
            lost = int(user["coin"] * 0.25)
            user["coin"] -= lost
            _save_user(user)
            return f"üí• {username} b·ªã b√£o bi·ªÉn cu·ªën m·∫•t {_fmt(lost)} coin!"

    # ===== PVP =====
    elif action == "krob":
        if len(parts) < 2:
            return "‚ùå D√πng: `krob <@user|username>`"
        now = time.time()
        if now - user["last_pvp"] < PVP_CD:
            remain = int((PVP_CD - (now - user["last_pvp"])) / 60)
            return f"‚öîÔ∏è C·∫ßn ch·ªù {remain} ph√∫t n·ªØa ƒë·ªÉ c∆∞·ªõp ti·∫øp!"
        target_key = _find_user_key_by_token(parts[1])
        if not target_key:
            return "‚ùå Kh√¥ng t√¨m th·∫•y n·∫°n nh√¢n!"
        target = _get_user_by_id(target_key)
        if not target or target["coin"] <= 0:
            return "üí∏ N·∫°n nh√¢n kh√¥ng c√≥ coin!"
        user["last_pvp"] = now
        if random.random() < 0.5:
            rate = random.uniform(0.1, 0.3)
            stolen = int(target["coin"] * rate)
            target["coin"] -= stolen; user["coin"] += stolen
            _save_user(target); _save_user(user)
            return f"üè¥‚Äç‚ò†Ô∏è {username} c∆∞·ªõp th√†nh c√¥ng {_fmt(stolen)} coin t·ª´ {target['username']}!"
        else:
            penalty = int(user["coin"] * 0.1)
            user["coin"] -= penalty; _save_user(user)
            return f"üí• {username} b·ªã ph·∫£n ƒë√≤n v√† m·∫•t {_fmt(penalty)} coin!"

    # ===== DAILY =====
    elif action == "kdaily":
        dp = user["daily_progress"]
        if dp.get("completed", False):
            return "‚úÖ B·∫°n ƒë√£ ho√†n th√†nh nhi·ªám v·ª• h√¥m nay r·ªìi!"
        if dp["farm"] >= 10:
            reward = random.randint(500, 1000)
            user["coin"] += reward
            item = random.choice(list(shop_items.keys()))
            inv = user["inventory"]; inv[item] = inv.get(item, 0) + 1
            dp["completed"] = True
            _save_user(user)
            return f"üéâ Ho√†n th√†nh nhi·ªám v·ª• h·∫±ng ng√†y! Th∆∞·ªüng {_fmt(reward)} coin + 1 {item}!"
        else:
            return f"üìã Nhi·ªám v·ª• h√¥m nay: Farm 10 l·∫ßn (hi·ªán t·∫°i: {dp['farm']}/10)."

    # ===== MINI-GAME =====
    elif action == "kcf":
        if len(parts) < 3:
            return "‚ùå D√πng: `kcf <ti·ªÅn_c∆∞·ª£c> <h|t>`"
        bet = _parse_pos_int(parts[1]); side = parts[2]
        return _coinflip_play(user, bet, side)

    elif action == "os":
        if len(parts) < 2:
            return "‚ùå D√πng: `os <ti·ªÅn_c∆∞·ª£c>`"
        bet = _parse_pos_int(parts[1])
        return _slots_play(user, bet)

    elif action == "obj":
        if len(parts) < 2:
            return "‚ùå D√πng: `obj <ti·ªÅn_c∆∞·ª£c>`"
        bet = _parse_pos_int(parts[1])
        return _bj_play(user, bet)

    # ===== SHOP / BUY =====
    elif action == "kshop":
        lines = []
        for name, price in shop_items.items():
            if name in tool_bonus:
                lines.append(f"- {name}: {_fmt(price)} coin (bonus +{tool_bonus[name]}/l·∫ßn farm)")
            elif name == "khien":
                lines.append(f"- {name}: {_fmt(price)} coin (gi·∫£m 15% t·ªâ l·ªá ch·∫øt, ti√™u 1/l·∫ßn)")
            elif name == "khienvip":
                lines.append(f"- {name}: {_fmt(price)} coin (MI·ªÑN T·ª¨ 100%, m·ªói m√≥n = 10 l∆∞·ª£t)")
            elif name == "thuoc":
                lines.append(f"- {name}: {_fmt(price)} coin (booster x2 coin trong 5 ph√∫t khi d√πng)")
        return "üè™ **C·ª≠a h√†ng:**\n" + "\n".join(lines) + "\n\nüß™ D√πng booster: `kdung thuoc` ‚Ä¢ `kstatus` xem tr·∫°ng th√°i"

    elif action == "kmua":
        if len(parts) < 3:
            return "‚ùå D√πng: `kmua <v·∫≠t_ph·∫©m> <s·ªë_l∆∞·ª£ng>`"
        item = parts[1]; sl = _parse_pos_int(parts[2])
        if item not in shop_items or sl is None:
            return "‚ùå Kh√¥ng h·ª£p l·ªá!"
        cost = shop_items[item] * sl
        if user["coin"] < cost:
            return f"‚ùå Kh√¥ng ƒë·ªß coin! C·∫ßn {_fmt(cost)}, b·∫°n c√≥ {_fmt(user['coin'])}."
        user["coin"] -= cost
        inv = user["inventory"]
        if item == "khienvip":
            inv["khienvip"] = int(inv.get("khienvip", 0)) + 10 * sl  # 1 m√≥n = 10 l∆∞·ª£t
        else:
            inv[item] = int(inv.get(item, 0)) + sl
        _save_user(user)
        return f"üõí Mua {_fmt(sl)} {item} v·ªõi gi√° {_fmt(cost)} coin. (C√≤n l·∫°i: {_fmt(user['coin'])})"

    # ===== INVENTORY / TOP =====
    elif action in ["kkho", "kinv"]:
        inv = user["inventory"]
        items = "\n".join([f"- {i}: {_fmt(v)}" for i, v in inv.items()]) or "Kh√¥ng c√≥ g√¨."
        return f"üéí **Kho c·ªßa {username}:**\n{items}\nüí∞ Coin: {_fmt(user['coin'])}\nüèÖ Level {user['level']} ({_fmt(user['exp'])} exp)"

    elif action == "ktop":
        conn = _db(); cur = conn.cursor()
        cur.execute("SELECT username, coin, level FROM players ORDER BY coin DESC LIMIT 10")
        rows = cur.fetchall(); conn.close()
        msg = "üèÜ **Top 10 ng∆∞·ªùi gi√†u nh·∫•t:**\n"
        for i, r in enumerate(rows, 1):
            msg += f"{i}. {r['username']} - {_fmt(r['coin'])} coin - Lv {r['level']}\n"
        return msg if rows else "Ch∆∞a c√≥ ai trong b·∫£ng x·∫øp h·∫°ng."

    # ===== ADMIN: BAN / UNBAN / RESET / COIN / LV / SETADMIN / SETDEATH / CHANNEL =====
    elif action == "kban":
        if not user["is_admin"]:
            return "‚ùå Ch·ªâ admin ƒë∆∞·ª£c d√πng!"
        if len(parts) < 2:
            return "‚ùå D√πng: `kban <@user|username>`"
        target_key = _find_user_key_by_token(parts[1])
        if not target_key: return "‚ùå Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi ch∆°i!"
        target = _get_user_by_id(target_key); target["ban"] = True; _save_user(target)
        return f"üö´ ƒê√£ **ban** {target['username']}."

    elif action == "kunban":
        if not user["is_admin"]:
            return "‚ùå Ch·ªâ admin ƒë∆∞·ª£c d√πng!"
        if len(parts) < 2:
            return "‚ùå D√πng: `kunban <@user|username>`"
        target_key = _find_user_key_by_token(parts[1])
        if not target_key: return "‚ùå Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi ch∆°i!"
        target = _get_user_by_id(target_key); target["ban"] = False; _save_user(target)
        return f"‚úÖ ƒê√£ **g·ª° ban** {target['username']}."

    elif action == "krs":
        if not user["is_admin"]:
            return "‚ùå Ch·ªâ admin ƒë∆∞·ª£c d√πng!"
        if len(parts) < 2:
            return "‚ùå D√πng: `krs <@user|username>`"
        target_key = _find_user_key_by_token(parts[1])
        if not target_key: return "‚ùå Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi ch∆°i!"
        target = _get_user_by_id(target_key); _reset_user_fields(target); _save_user(target)
        return f"‚ôªÔ∏è ƒê√£ **reset s·∫°ch** d·ªØ li·ªáu c·ªßa {target['username']}."

    elif action == "kaddcoin":
        if not user["is_admin"]:
            return "‚ùå Ch·ªâ admin ƒë∆∞·ª£c d√πng!"
        if len(parts) < 3:
            return "‚ùå D√πng: `kaddcoin <@user|username> <s·ªë_coin>`"
        target_key = _find_user_key_by_token(parts[1]); amount = _parse_pos_int(parts[2])
        if not target_key or amount is None: return "‚ùå C√∫ ph√°p sai!"
        target = _get_user_by_id(target_key); target["coin"] += amount; _save_user(target)
        return f"üí∞ +{_fmt(amount)} coin cho {target['username']} (hi·ªán c√≥ {_fmt(target['coin'])})."

    elif action == "kremovecoin":
        if not user["is_admin"]:
            return "‚ùå Ch·ªâ admin ƒë∆∞·ª£c d√πng!"
        if len(parts) < 3:
            return "‚ùå D√πng: `kremovecoin <@user|username> <s·ªë_coin>`"
        target_key = _find_user_key_by_token(parts[1]); amount = _parse_pos_int(parts[2])
        if not target_key or amount is None: return "‚ùå C√∫ ph√°p sai!"
        target = _get_user_by_id(target_key)
        if target["coin"] < amount: amount = target["coin"]
        target["coin"] -= amount; _save_user(target)
        return f"üí∏ ƒê√£ tr·ª´ {_fmt(amount)} coin c·ªßa {target['username']} (c√≤n {_fmt(target['coin'])})."

    elif action == "ksetlv":
        if not user["is_admin"]:
            return "‚ùå Ch·ªâ admin ƒë∆∞·ª£c d√πng!"
        if len(parts) < 3:
            return "‚ùå D√πng: `ksetlv <@user|username> <level>`"
        target_key = _find_user_key_by_token(parts[1]); lvl = _parse_pos_int(parts[2])
        if not target_key or lvl is None: return "‚ùå C√∫ ph√°p sai!"
        target = _get_user_by_id(target_key); target["level"] = lvl; target["exp"] = 0; _save_user(target)
        return f"üèÖ ƒê√£ ƒë·∫∑t level c·ªßa {target['username']} = {lvl}."

    elif action == "ksetadmin":
        if not user["is_admin"]:
            return "‚ùå Ch·ªâ admin ƒë∆∞·ª£c d√πng!"
        if len(parts) < 3:
            return "‚ùå D√πng: `ksetadmin <@user|username> <on|off>`"
        target_key = _find_user_key_by_token(parts[1]); val = parts[2].lower()
        if not target_key or val not in ("on","off"): return "‚ùå C√∫ ph√°p sai!"
        target = _get_user_by_id(target_key); target["is_admin"] = (val == "on"); _save_user(target)
        state = "c·∫•p **admin**" if val=="on" else "thu h·ªìi **admin**"
        return f"üõ†Ô∏è ƒê√£ {state} cho {target['username']}."

    elif action == "ksetdeath":
        if not user["is_admin"]:
            return "‚ùå Ch·ªâ admin ƒë∆∞·ª£c d√πng!"
        if len(parts) < 2:
            return "‚ùå D√πng: `ksetdeath <ph·∫ßn_trƒÉm>` (vd: 25)"
        try: pct = int(parts[1])
        except ValueError: return "‚ùå Ph·∫£i l√† s·ªë nguy√™n 0‚Äì100."
        if not (0 <= pct <= 100): return "‚ùå Ph·∫£i trong kho·∫£ng 0‚Äì100."
        _set_setting("death_chance", pct / 100.0)
        return f"‚úÖ ƒê√£ ƒë·∫∑t t·ªâ l·ªá ch·∫øt = {pct}%."

    elif action == "ksetchannel":
        if not user["is_admin"]:
            return "‚ùå Ch·ªâ admin ƒë∆∞·ª£c d√πng!"
        if len(parts) < 2:
            return "‚ùå D√πng: `ksetchannel <#k√™nh>`"
        ch = parts[1].strip("<#>")
        if not ch.isdigit(): return "‚ùå Sai c√∫ ph√°p, tag ƒë√∫ng k√™nh nh√©!"
        _set_setting("farm_channel_id", int(ch))
        return f"‚úÖ ƒê√£ set k√™nh farm c·ªë ƒë·ªãnh: <#{ch}>"

    elif action == "kunsetchannel":
        if not user["is_admin"]:
            return "‚ùå Ch·ªâ admin ƒë∆∞·ª£c d√πng!"
        if _get_setting("farm_channel_id") is None:
            return "‚ö†Ô∏è Ch∆∞a c√≥ k√™nh n√†o ƒë∆∞·ª£c set."
        _set_setting("farm_channel_id", None)
        return "‚úÖ ƒê√£ h·ªßy set k√™nh farm ‚Äî gi·ªù c√≥ th·ªÉ farm ·ªü m·ªçi n∆°i!"

    # ===== HELP =====
    elif action == "khelp":
        return """
üìú **H∆Ø·ªöNG D·∫™N L·ªÜNH ƒê·∫¢O HOANG (SQLite .db)**

üåæ `kfarm` ‚Üí ƒê√†o coin (5‚Äì10 + bonus cu·ªëc, 10s h·ªìi) ‚Ä¢ 35% ch·∫øt; khi√™n th∆∞·ªùng -15% ‚Ä¢ Admin: kh√¥ng cooldown
üß™ `kdung thuoc` ‚Üí D√πng booster x2 farm trong 5 ph√∫t (ti√™u hao) ‚Ä¢ `kstatus` xem tr·∫°ng th√°i
üß≠ `kadventure` (30') ‚Ä¢ ‚öîÔ∏è `krob <@user|username>` (1h)
üìÖ `kdaily` nhi·ªám v·ª• h·∫±ng ng√†y ‚Ä¢ üèÜ `ktop` b·∫£ng x·∫øp h·∫°ng

üé≤ **Mini-game**
`kcf <ti·ªÅn> <h|t>` ‚Ä¢ `os <ti·ªÅn>` ‚Ä¢ `obj <ti·ªÅn>`

üè™ `kshop` / `kmua <item> <s·ªë_l∆∞·ª£ng>`
üõ°Ô∏è `khien` (gi·∫£m 15%/l·∫ßn) ‚Ä¢ `khienvip` (MI·ªÑN T·ª¨ 100%, m·ªói m√≥n = 10 l∆∞·ª£t)
üî® Cu·ªëc: g·ªó +1 ‚Ä¢ s·∫Øt +2 ‚Ä¢ v√†ng +5 ‚Ä¢ kim c∆∞∆°ng +10

**Admin:**
`kban <@user>` / `kunban <@user>` ‚Ä¢ `krs <@user>` (reset d·ªØ li·ªáu)
`kaddcoin <@user> <coin>` / `kremovecoin <@user> <coin>`
`ksetlv <@user> <level>` ‚Ä¢ `ksetadmin <@user> <on|off>`
`ksetdeath <percent>` ‚Ä¢ `ksetchannel #k√™nh` / `kunsetchannel`
"""

    else:
        return "‚ùå L·ªánh kh√¥ng h·ª£p l·ªá! D√πng `khelp` ƒë·ªÉ xem h∆∞·ªõng d·∫´n."
